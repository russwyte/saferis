package saferis

import zio.*

import java.sql.ResultSet
import scala.annotation.StaticAnnotation

/** Represents a label for a column in a result set. Fields in a case class can be annotated with this to specify the
  * column name/label Example:
  * {{{
  *   case class User(
  *     @label("user_id") id: Int,
  *     @label("user_name") name: String
  *   )
  * }}}
  *
  * @param name
  */
final case class label(name: String) extends StaticAnnotation

/** denotes fields of a case class that are generated by the database
  */
class generated extends key

/** denotes fields of a case class that make up a primary key
  */
class key extends StaticAnnotation

/** denotes fields of a case class that should be indexed
  *
  * When multiple fields share the same index name, they form a compound index.
  *
  * Example:
  * {{{
  *   case class Event(
  *     @key id: Int,
  *     @indexed tenantId: Int,                   // Single-column index
  *     @indexed("compound_idx") userId: Int,    // Compound index
  *     @indexed("compound_idx") eventTime: Long // Same name = same compound index
  *   ) derives Table
  *
  *   // Partial index with WHERE clause:
  *   case class CommandRow(
  *     @key id: Long,
  *     @indexed("idx_pending", "status = 'pending'") nextRetryAt: Instant,
  *     status: String
  *   ) derives Table
  * }}}
  *
  * @param name
  *   Optional index name. Columns with the same name form a compound index.
  * @param condition
  *   Optional WHERE clause condition for partial indexes.
  */
final case class indexed(name: String = "", condition: String = "") extends StaticAnnotation

/** denotes fields of a case class that should have a unique index
  *
  * When multiple fields share the same index name, they form a compound unique index.
  *
  * Example:
  * {{{
  *   case class Event(
  *     @key id: Int,
  *     @uniqueIndex email: String,                        // Single-column unique index
  *     @uniqueIndex("compound_idx") tenantId: Int,        // Compound unique index
  *     @uniqueIndex("compound_idx") eventId: Long         // Same name = same compound index
  *   ) derives Table
  *
  *   // Partial unique index with WHERE clause:
  *   case class User(
  *     @key id: Long,
  *     @uniqueIndex("idx_active_email", "active = true") email: String,
  *     active: Boolean
  *   ) derives Table
  * }}}
  *
  * @param name
  *   Optional index name. Columns with the same name form a compound unique index.
  * @param condition
  *   Optional WHERE clause condition for partial unique indexes.
  */
final case class uniqueIndex(name: String = "", condition: String = "") extends StaticAnnotation

/** denotes fields of a case class that should have a unique constraint at the column level
  *
  * When multiple fields share the same constraint name, they form a compound unique constraint.
  *
  * Example:
  * {{{
  *   case class Event(
  *     @key id: Int,
  *     @unique instanceId: String,           // Single-column unique constraint
  *     @unique("composite") tenantId: Int,   // Compound unique constraint
  *     @unique("composite") eventId: Long    // Same name = same constraint
  *   ) derives Table
  * }}}
  *
  * @param name
  *   Optional constraint name. Columns with the same name form a compound unique constraint.
  */
final case class unique(name: String = "") extends StaticAnnotation

/** Represents a column/field in result set
  *
  * @param name
  *   the scala field name in the case class
  * @param label
  *   the column name/label in the result set
  * @param reader
  */
final case class Column[R: Decoder as readable: Encoder as writable](
    name: String,
    label: String,
    isKey: Boolean,
    isGenerated: Boolean,
    isIndexed: Boolean,
    isUniqueIndex: Boolean,
    isUnique: Boolean,
    isNullable: Boolean,
    uniqueGroup: Option[String],
    indexGroup: Option[String],
    uniqueIndexGroup: Option[String],
    indexCondition: Option[String],
    uniqueIndexCondition: Option[String],
    defaultValue: Option[R],
    tableAlias: Option[String],
) extends Placeholder:
  type ColumnType = R
  val writes = Seq.empty
  // Note: We cannot access dialect here as Column is constructed at compile-time
  // The label should already be the raw identifier, escaping happens at usage site
  val sql = tableAlias.fold(label)(a => s"$a.$label")

  private[saferis] def read(rs: ResultSet)(using Trace): Task[(String, R)] =
    readable.decode(rs, label).map(v => name -> v)
  private[saferis] def withTableAlias(alias: Option[String]) = copy(tableAlias = alias)

  // Provide SQL type information based on the encoder
  private[saferis] def sqlType: Int                                                          = writable.jdbcType
  private[saferis] def columnType(using dialect: Dialect = postgres.PostgresDialect): String =
    writable.columnType

  /** Returns the DEFAULT clause for DDL if a default value is defined */
  private[saferis] def defaultClause: Option[String] =
    defaultValue.map(v => s"default ${writable.literal(v)}")
end Column
